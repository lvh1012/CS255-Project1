1. Briefly describe your method for preventing the adversary from learning information about
the lengths of the passwords stored in your password manager
=> password có độ dài tối đa là 64 bytes. Nếu password có kích thước < 64 bytes sẽ được thêm
padding sao cho kích thước = 64 bytes. Do đó, tất cả các password được lưu trữ có kích thước
bằng nhau
keychain  = {HMAC(domain), AE(padded_password || HMAC(domain))}
2. Briefly describe your method for preventing swap attacks (Section 2.2). Provide an argument
for why the attack is prevented in your scheme.
=> Mỗi padded password sẽ được nối với mã HMAC của domain trước khi encrypt.
Nếu một cuộc tấn công hoán đổi xảy ra, thì HMAC của key(domain) sẽ không khớp
với HMAC được mã hóa bên trong value.
3. In our proposed defense against the rollback attack (Section 2.2), we assume that we can store
the SHA-256 hash in a trusted location beyond the reach of an adversary. Is it necessary to
assume that such a trusted location exists, in order to defend against rollback attacks? Briefly
justify your answer.
=> Cần giả định rằng lưu trữ mã SHA256 tại một nơi an toàn.
Giả sử chuỗi khóa được bảo mật trước các lần khôi phục nhưng không có vị trí đáng tin cậy.
Attacker có thể truy cập được mọi dữ liệu trên đĩa. Attacker lưu giữ thông tin keychain và mã SHA256
tại thời điểm t1. Tại thời điểm t2, attacker có thể khôi phục lại các bản ghi cũ vì mã SHA256 hoàn toàn
hợp lệ
4. Because HMAC is a deterministic MAC (that is, its output is the same if it is run multiple
times with the same input), we were able to look up domain names using their HMAC values.
There are also randomized MACs, which can output different tags on multiple runs with the
same input. Explain how you would do the look up if you had to use a randomized MAC
instead of HMAC. Is there a performance penalty involved, and if so, what?
=> kết hợp ECBC‐MAC sử dụng AES-128 và random IV. Sinh ra 2 khóa key1 và key2 để tạo mã MAC. 
random IV được đính kèm cùng với mã MAC của domain và lưu vào keychain
5. In our specification, we leak the number of records in the password manager. Describe an
approach to reduce the information leaked about the number of records. Specifically, if there
are k records, your scheme should only leak |log2(k)| (that is, if k1 and k2 are such that
|log2(k1)| = |log2(k2)|, the attacker should not be able to distinguish between a case where
the true number of records is k1 and another case where the true number of records is k2).
=>
6. What is a way we can add multi-user support for specific sites to our password manager
system without compromising security for other sites that these users may wish to store
passwords of? That is, if Alice and Bob wish to access one stored password (say for anytimes)
that either of them can get and update, without allowing the other to access their passwords
for other websites.
=>